> 출처: https://www.developerway.com/posts/react-compiler-soon > https://velog.io/@eunbinn/react-compiler-soon

지난 한 달간 리액트 19와 React Forget으로 알려진 리액트 컴파일러에 대한 이야기로 리액트 커뮤니티가 뜨거웠습니다. 우리 모두는 머지 않아 리액트에서 메모에 대해 생각할 필요가 없어질 수 있다는 것에 대해 (좋은 의미로) 마음을 빼앗겼습니다. 하지만 정말로 그럴까요? 앞으로 몇 달 안에 memo, useMemo 그리고 useCallback을 잊어야 할까요? 그리고 리액트 컴파일러가 출시되면 실제로 무엇이 바뀌며, 그 이후에는 리액트에 대해 무엇을 배우고 가르쳐야 할까요?

### React 19는 React 컴파일러가 아닙니다.

가장 중요한 것을 먼저 말씀드리자면, 메모이제이션은 곧바로 사라지지 않을 것이기 때문에 아직은 잊어서는 안됩니다. 리액트 19는 리액트 컴파일러가 아닙니다. 리액트 팀은 리액트 19가 곧 출시됨을 발표하는 하나의 블로그 게시물에서 컴파일러에 대해서도 발표했고, 모두가 흥분하여 이 둘이 함께 한다는 섣부른 결론을 내렸습니다.

리액트 팀 멤버의 트윗이 이러한 혼란을 명확히 해줍니다.

![](https://velog.velcdn.com/images/ronney/post/0901a78b-9dc4-4005-943e-ccfe9a3a85c8/image.png)

React 19에서는 많은 새로운 기능을 볼 수 있지만 컴파일러는 좀 더 기다려야 합니다. 지금으로서는 얼마나 오래 걸릴지 확실하지 않지만, 다른 React 핵심 팀원의 또 다른 트윗에 따르면 올해 말까지 일어날 수 있다고 합니다.

---

개인적으로 저는 이 타임라인에 대해 회의적입니다. 컴파일러와 그 타임라인을 소개한 React 팀 구성원 의 강연을 살펴보면 우리는 컴파일러 여정의 한가운데에 있습니다.

여정은 2년 전인 2021년에 시작되었습니다. Meta 처럼 규모가 큰 코드베이스에서 이렇게 근간이 되는 기능을 출시하는 것은 매우 복잡한 일일 것입니다. 그렇기 때문에 타임라인의 중간에서 끝으로 넘어가는 데에도 또다시 2년이 걸릴 수도 있습니다.

하지만 또 모르죠, 리액트 팀은 올해에 출시되도록 작업할 수도 있습니다. 그렇다면 좋은 소식일 것입니다. 비디오에서 언급한 바에 따르면 리액트 팀은 코드를 변경하지 않고도 새로운 컴파일러를 적용할 수 있음을 약속합니다. 그냥 작동할 거에요. 실제로 연말까지 출시된다면 정말로 그냥 동작할 것이라는 좋은 신호이며 사용자들은 빠르고 쉽게 전환할 수 있을 것입니다.

**하지만 올해 컴파일러가 출시되고 실제로 단점 없이 매우 쉽게 도입할 수 있다고 해도, useCallback과 memo를 바로 잊어도 된다는 의미는 아닙니다.** "이미 컴파일러가 활성화된 경우"에 대해 먼저 이야기한 다음 "아직 컴파일러로 마이그레이션하지 않은 드문 경우"의 시나리오로 천천히 전환하는 **"전환" 기간**이 반드시 존재할 것입니다.

**클래스 컴포넌트에서 훅이 있는 함수형 컴포넌트로의 전환은 심적으로 적어도 3년(2018년부터)은 걸린 것 같습니다.** 모든 강좌, 문서, 블로그가 따라잡으면서 대부분의 사람들이 훅이 있는 리액트 버전으로 마이그레이션했고, 우리는 함수형 컴포넌트와 훅을 기본으로 이야기하기 시작했습니다. 하지만 6년이 지난 지금도 여전히 여기저기에 많은 클래스 컴포넌트가 숨어 있습니다.

**비슷한 타임라인을 컴파일러에도 적용해보면 적어도 향후 3년 동안은 memo, useMemo, useCallback이 무엇인지에 대한 지식을 유지해야 한다는 뜻이 됩니다.** 운이 좋게도 컴파일러가 출시되는 즉시 마이그레이션 할 수 있는 최신 코드베이스에서 작업하는 경우라면 그보다 짧을 수 있습니다. 레거시 코드가 많아 마이그레이션 속도가 느린 대규모 코드베이스에서 작업하거나 리액트를 가르치는 선생님이라면 더 오래 걸릴 수 있습니다.

```
바로 잊어도 되는것이 아니다  , 이전 클래스 => 함수형 컴포넌트 마이그레이션 기간은 작성자 체감상 3년이상 소요됨 이런 경험으로 최소 3년동안은 지식이 유지되어야 할 수있음, 코드베이스에 따라 다름
```

## React Compiler 변경되는 것들

그래서 정확히 무엇이 바뀌는건가요? 간단히 말하자면, 이제 모든 것이 메모화된다는 것입니다. 리액트 컴파일러는 일반적인 리액트 코드를 모든 훅의 종속성, 컴포넌트의 프로퍼티 및 컴포넌트 자체가 메모화된 코드로 변환하는 Babel 플러그인이 될 것입니다. 예를 들어 아래와 같은 코드가 있다고 하겠습니다.

```
const Component = () => {
  const onSubmit = () => {};
  const onMount = () => {};

  useEffect(() => {
    onMount();
  }, [onMount]);

  return <Form onSubmit={onSubmit} />;
};
```

내부적으로 이 코드는 onSubmit과 onMount는 모두 useCallback으로 감싸지고 Form은 React.memo로 **감싸진 것처럼 동작**할 것입니다.

```
const FormMemo = React.memo(Form);

const Component = () => {
  const onSubmit = useCallback(() => {}, []);
  const onMount = useCallback(() => {}, []);

  useEffect(() => {
    onMount();
  }, [onMount]);

  return <FormMemo onSubmit={onSubmit} />;
};
```

물론 컴파일러가 정확히 이 코드로 변환하는 것은 아니며 이보다 훨씬 더 복잡하고 발전된 형태일 것입니다. 하지만 간단히 이해하기에는 좋은 예시입니다.

우리가 React를 가르치고 배우는 방식에 있어 이러한 전환은 몇 가지 의미를 갖습니다.

### 부모가 다시 렌더링하면 자식도 다시 렌더링됩니다.

현재 상위 구성 요소가 다시 렌더링되면 내부에 렌더링된 모든 구성 요소도 다시 렌더링됩니다.

```
// 부모 컴포넌트가 리렌더링되면
const Parent = () => {
  // 자식 컴포넌트도 리렌더링됩니다
  return <Child />;
};
```

현재 많은 사람들은 Child 컴포넌트는 props가 변경될 때만 리렌더링된다고 생각합니다. 이는 사실이 아닙니다. 표준 리액트 동작에서 props는 중요하지 않습니다.

재밌게도 이는 컴파일러에선 사실이 됩니다. 모든 것이 메모화되어 있기 때문에 현재의 속설은 실제로 표준 리액트 동작이 됩니다. 몇 년 안에는 리액트 컴포넌트는 상태나 props가 변경될 때만 리렌더링되며, 부모가 리렌더링되는지 여부는 중요하지 않다고 가르쳐야 합니다.

### 더 이상 성능을 위한 구성이 필요하지 않습니다.

현재 리렌더링을 줄일 수 있는 "상태를 아래로 이동시키기"나 "컴포넌트를 자식으로 전달"과 같은 몇 가지 합성 기법이 있습니다. 리액트에서 메모이제이션을 제대로 하는 것은 매우 어렵기 때문에 저는 보통 useCallback과 memo를 사용하기 전에 이 기법들을 사용하기를 권장합니다.

예를 들어 다음 코드에서는 다음과 같습니다.

```
const Component = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>open dialog</Button>
      {isOpen && <ModalDialog />}
      <VerySlowComponent />
    </>
  );
};
```

*VerySlowComponent*는 매번 ModalDialog가 열릴 때마다 리렌더링되어(부모 컴포넌트 상태가 변경되어 자식 컴포넌트가 리랜더링 됨) 대화 상자가 열리는 것을 지연시킵니다. ModalDialog를 여는 상태를 캡슐화하면 다음과 같이 작성할 수 있습니다.

```
const ButtonWithDialog = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button onClick={() => setIsOpen(true)}>open dialog</Button>
      {isOpen && <ModalDialog />}
    </>
  );
};

const Component = () => {
  return (
    <>
      <ButtonWithDialog />
      <VerySlowComponent />
    </>
  );
};
```

컴파일러가 활성화되면 이러한 패턴은 성능에 불필요해집니다. 우리는 아마도 관심사의 구성과 분리 목적으로 그것들을 계속 사용할 것입니다. 그러나 구성 요소를 더 작은 구성 요소로 분할하도록 강제하는 자연스러운 재렌더링 기능은 더 이상 존재하지 않습니다. 우리의 구성 요소는 부정적인 결과 없이 더 커질 수 있습니다.

### 더 이상 어디에서나 useMemo/useCallback이 필요하지 않습니다.

당연히 우리의 코드를 괴롭히던 useMemo와 useCallback이 모두 사라질 것입니다. 이 부분이 제일 마음에 듭니다. 이제 더이상 onSubmit props 콜백 하나를 기억하기 위해 여러 단계의 컴포넌트를 통해 props를 추적하지 않아도 됩니다. 서로 의존성이 얽혀있고 이해하기 불가능했던 읽기 어렵고 디버깅할 수 없는 useMemo와 useCallback 체인은 더 이상 없습니다. children이 메모이제이션 되지 않아 아무도 눈치채지 못한 채 메모이제이션이 깨지는 일도 이제 없습니다.

_**article 작성자의 주석**_

> 하지만 이는 제한적으로 공개된 리소스를 바탕으로 제가 가정한 것이기 때문에 약간 틀릴 수도 있습니다. 어쨌든 이는 우리의 프로덕션 코드에서는 크게 중요하지 않은 구현 세부 사항일 뿐입니다.

** article에 대한 나의 이해**

> #### React Compiler 출시 이후에는 어떻게 바뀔까?
>
> 개발자 입장에서 논베이스 코드 작성시 크게 달라지는 부분이 없을 것이다
> 왜냐하면 react compiler가 자동적으로 memoization을 적용해 최적화된 애플리케이션을 만들어 낼 것이기 때문이다.
> 라이브러리 이해도를 위해 Memoization의 개념, 그리고 React Compiler의 역할 개념을 잘 이해해야하는 것이 좋겠다.
